<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Shogi</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* 追加のスタイル調整 */
        body {
            background-color: #fafafa; /* zinc-50 */
            /* タブレットでの誤操作防止 */
            touch-action: manipulation;
            overscroll-behavior: none;
        }
        
        /* 100dvh for mobile browsers */
        .h-dvh {
            height: 100vh;
            height: 100dvh;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons (Lucide Icons SVG replacement) ---
        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className}
            >
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/>
                <path d="M3 3v9h9"/>
            </svg>
        );

        // --- Constants & Types ---

        const PLAYER_SENTE = 'sente'; // 先手 (Bottom/Right)
        const PLAYER_GOTE = 'gote';   // 後手 (Top/Left)

        const PIECE_TYPES = {
          FU: 'FU', KY: 'KY', KE: 'KE', GI: 'GI', KI: 'KI',
          KA: 'KA', HI: 'HI', OU: 'OU',
        };

        const PROMOTED_TYPES = {
          FU: 'TO', KY: 'NY', KE: 'NK', GI: 'NG',
          KA: 'UM', HI: 'RY',
        };

        // フルネーム表記
        const PIECE_KANJI = {
          FU: '歩兵', TO: 'と金',
          KY: '香車', NY: '成香',
          KE: '桂馬', NK: '成桂',
          GI: '銀将', NG: '成銀',
          KI: '金将',
          KA: '角行', UM: '龍馬',
          HI: '飛車', RY: '龍王',
          OU: '王将',
        };

        // --- Game Logic Helpers ---

        const createInitialBoard = () => {
          const board = Array(9).fill(null).map(() => Array(9).fill(null));
          const place = (row, col, type, owner) => {
            board[row][col] = { type, owner, promoted: false };
          };

          // Gote (Top)
          place(0, 0, PIECE_TYPES.KY, PLAYER_GOTE);
          place(0, 1, PIECE_TYPES.KE, PLAYER_GOTE);
          place(0, 2, PIECE_TYPES.GI, PLAYER_GOTE);
          place(0, 3, PIECE_TYPES.KI, PLAYER_GOTE);
          place(0, 4, PIECE_TYPES.OU, PLAYER_GOTE);
          place(0, 5, PIECE_TYPES.KI, PLAYER_GOTE);
          place(0, 6, PIECE_TYPES.GI, PLAYER_GOTE);
          place(0, 7, PIECE_TYPES.KE, PLAYER_GOTE);
          place(0, 8, PIECE_TYPES.KY, PLAYER_GOTE);
          place(1, 1, PIECE_TYPES.HI, PLAYER_GOTE);
          place(1, 7, PIECE_TYPES.KA, PLAYER_GOTE);
          for (let i = 0; i < 9; i++) place(2, i, PIECE_TYPES.FU, PLAYER_GOTE);

          // Sente (Bottom)
          place(8, 0, PIECE_TYPES.KY, PLAYER_SENTE);
          place(8, 1, PIECE_TYPES.KE, PLAYER_SENTE);
          place(8, 2, PIECE_TYPES.GI, PLAYER_SENTE);
          place(8, 3, PIECE_TYPES.KI, PLAYER_SENTE);
          place(8, 4, PIECE_TYPES.OU, PLAYER_SENTE);
          place(8, 5, PIECE_TYPES.KI, PLAYER_SENTE);
          place(8, 6, PIECE_TYPES.GI, PLAYER_SENTE);
          place(8, 7, PIECE_TYPES.KE, PLAYER_SENTE);
          place(8, 8, PIECE_TYPES.KY, PLAYER_SENTE);
          place(7, 1, PIECE_TYPES.KA, PLAYER_SENTE);
          place(7, 7, PIECE_TYPES.HI, PLAYER_SENTE);
          for (let i = 0; i < 9; i++) place(6, i, PIECE_TYPES.FU, PLAYER_SENTE);

          return board;
        };

        const getPieceMoves = (piece, r, c, board) => {
          const moves = [];
          const isSente = piece.owner === PLAYER_SENTE;
          const forward = isSente ? -1 : 1;
          
          const check = (dr, dc, continuous = false) => {
            let nr = r + dr;
            let nc = c + dc;
            while (nr >= 0 && nr < 9 && nc >= 0 && nc < 9) {
              const target = board[nr][nc];
              if (target === null) {
                moves.push({ r: nr, c: nc });
                if (!continuous) break;
              } else {
                if (target.owner !== piece.owner) {
                  moves.push({ r: nr, c: nc }); 
                }
                break; 
              }
              nr += dr;
              nc += dc;
            }
          };

          const type = piece.promoted ? PROMOTED_TYPES[piece.type] || piece.type : piece.type;

          switch (type) {
            case PIECE_TYPES.FU: check(forward, 0); break;
            case PIECE_TYPES.KY: check(forward, 0, true); break;
            case PIECE_TYPES.KE:
              check(forward * 2, -1);
              check(forward * 2, 1);
              break;
            case PIECE_TYPES.GI:
              [[forward, -1], [forward, 0], [forward, 1], [-forward, -1], [-forward, 1]].forEach(d => check(d[0], d[1]));
              break;
            case PIECE_TYPES.KI:
            case PROMOTED_TYPES.FU:
            case PROMOTED_TYPES.KY:
            case PROMOTED_TYPES.KE:
            case PROMOTED_TYPES.GI:
              [[forward, -1], [forward, 0], [forward, 1], [0, -1], [0, 1], [-forward, 0]].forEach(d => check(d[0], d[1]));
              break;
            case PIECE_TYPES.OU:
              for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) if (dr || dc) check(dr, dc);
              break;
            case PIECE_TYPES.KA:
              [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(d => check(d[0], d[1], true));
              break;
            case PIECE_TYPES.HI:
              [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(d => check(d[0], d[1], true));
              break;
            case PROMOTED_TYPES.KA: 
              [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(d => check(d[0], d[1], true));
              [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(d => check(d[0], d[1]));
              break;
            case PROMOTED_TYPES.HI: 
              [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(d => check(d[0], d[1], true));
              [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(d => check(d[0], d[1]));
              break;
            default: break;
          }
          return moves;
        };

        // --- Modern Visual Components ---

        const ModernPiece = ({ type, owner, promoted, size = 'large', style = {} }) => {
          const isGote = owner === PLAYER_GOTE;
          const kanji = promoted ? (PROMOTED_TYPES[type] ? PIECE_KANJI[PROMOTED_TYPES[type]] : PIECE_KANJI[type]) : PIECE_KANJI[type];
          
          // 末広がりの五角形クリップパス
          // 頂点(50% 0%) -> 右肩(82% 25%) -> 右下(92% 100%) -> 左下(8% 100%) -> 左肩(18% 25%)
          const pentagonPath = 'polygon(50% 0%, 82% 25%, 92% 100%, 8% 100%, 18% 25%)';
          
          const chars = kanji.split('');

          return (
            <div 
              className={`
                relative flex flex-col items-center justify-center 
                select-none font-serif transition-transform duration-300
                ${size === 'large' ? 'h-[92%]' : 'h-8'}
              `}
              style={{
                transform: isGote ? 'rotate(180deg)' : 'rotate(0deg)',
                aspectRatio: '1 / 1',
                ...style
              }}
            >
              {/* 枠線用の黒背景 (Outer) */}
              <div 
                className="absolute inset-0 bg-zinc-900"
                style={{ clipPath: pentagonPath }}
              />
              
              {/* 内部の白背景 (Inner) - 1px小さくして枠線を表現 */}
              <div 
                className="absolute inset-[1px] bg-white"
                style={{ clipPath: pentagonPath }}
              />

              {/* 文字 (縦並び) */}
              <div className={`
                relative z-10 flex flex-col items-center justify-center leading-none
                ${promoted ? 'text-rose-700' : 'text-zinc-900'}
                ${size === 'large' ? 'gap-[1px] pt-1' : 'gap-0 pt-0.5'}
              `}>
                {chars.map((char, i) => (
                  <span key={i} className={`
                     ${size === 'large' ? 'text-sm sm:text-base md:text-lg font-bold' : 'text-[8px] font-bold'}
                  `}>
                    {char}
                  </span>
                ))}
              </div>
            </div>
          );
        };

        // --- Main Component ---

        function ModernShogi() {
          const [board, setBoard] = useState(createInitialBoard());
          const [turn, setTurn] = useState(PLAYER_SENTE);
          const [hands, setHands] = useState({ [PLAYER_SENTE]: [], [PLAYER_GOTE]: [] });
          const [selected, setSelected] = useState(null); 
          const [validDestinations, setValidDestinations] = useState([]);
          const [lastMove, setLastMove] = useState(null);
          const [promotionPending, setPromotionPending] = useState(null);

          // Animation State
          const [movingPiece, setMovingPiece] = useState(null);
          const boardRef = useRef(null);
          const cellRefs = useRef(Array(9).fill(null).map(() => Array(9).fill(null)));

          useEffect(() => {
            if (!selected) {
              setValidDestinations([]);
              return;
            }
            if (selected.type === 'board') {
              const piece = board[selected.r][selected.c];
              if (piece && piece.owner === turn) {
                setValidDestinations(getPieceMoves(piece, selected.r, selected.c, board));
              }
            } else if (selected.type === 'hand') {
              const moves = [];
              const piece = selected.piece;
              for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                  if (board[r][c] === null) {
                    if (piece.type === PIECE_TYPES.FU) {
                      let hasPawn = false;
                      for (let i = 0; i < 9; i++) if (board[i][c]?.owner === turn && board[i][c]?.type === PIECE_TYPES.FU && !board[i][c].promoted) hasPawn = true;
                      if (hasPawn) continue;
                      if (turn === PLAYER_SENTE && r === 0) continue;
                      if (turn === PLAYER_GOTE && r === 8) continue;
                    }
                    if (piece.type === PIECE_TYPES.KY) {
                       if (turn === PLAYER_SENTE && r === 0) continue;
                       if (turn === PLAYER_GOTE && r === 8) continue;
                    }
                     if (piece.type === PIECE_TYPES.KE) {
                       if (turn === PLAYER_SENTE && r <= 1) continue;
                       if (turn === PLAYER_GOTE && r >= 7) continue;
                    }
                    moves.push({ r, c });
                  }
                }
              }
              setValidDestinations(moves);
            }
          }, [selected, board, turn]);

          const handleSquareClick = (r, c) => {
            if (promotionPending || movingPiece) return;

            const target = board[r][c];

            if (!selected) {
              if (target && target.owner === turn) {
                setSelected({ type: 'board', r, c });
              }
              return;
            }

            if (selected.type === 'board' && selected.r === r && selected.c === c) {
              setSelected(null);
              return;
            }
            if (target && target.owner === turn) {
              setSelected({ type: 'board', r, c });
              return;
            }

            const isValid = validDestinations.some(m => m.r === r && m.c === c);
            if (isValid) {
              prepareMove(selected, r, c);
            } else {
              setSelected(null);
            }
          };

          const handleHandClick = (owner, index, piece, event) => {
            if (promotionPending || movingPiece) return;
            if (owner !== turn) return;

            if (selected && selected.type === 'hand' && selected.index === index) {
              setSelected(null);
            } else {
              setSelected({ type: 'hand', index, piece });
            }
          };

          const prepareMove = (from, toR, toC) => {
            let startRect = null;
            let endRect = null;
            let animatedPiece = null;

            if (cellRefs.current[toR] && cellRefs.current[toR][toC]) {
              endRect = cellRefs.current[toR][toC].getBoundingClientRect();
            }

            if (from.type === 'board') {
              if (cellRefs.current[from.r] && cellRefs.current[from.r][from.c]) {
                startRect = cellRefs.current[from.r][from.c].getBoundingClientRect();
              }
              animatedPiece = board[from.r][from.c];
            } else {
              if (boardRef.current) {
                 const boardRect = boardRef.current.getBoundingClientRect();
                 startRect = { 
                   top: boardRect.top + boardRect.height / 2 - 20, 
                   left: boardRect.left + boardRect.width / 2 - 20, 
                   width: 40, 
                   height: 40 
                 };
              }
              animatedPiece = from.piece;
            }

            if (startRect && endRect && animatedPiece) {
              setMovingPiece({
                piece: animatedPiece,
                fromPos: from.type === 'board' ? {r: from.r, c: from.c} : 'hand',
                startRect,
                endRect,
                toR, toC,
                fromInfo: from
              });
            } else {
              executeMove(from, toR, toC);
            }
          };

          const onAnimationComplete = () => {
            if (!movingPiece) return;
            const { fromInfo, toR, toC } = movingPiece;
            setMovingPiece(null);
            executeMove(fromInfo, toR, toC);
          };

          const executeMove = (from, toR, toC) => {
            const newBoard = board.map(row => row.map(cell => cell ? {...cell} : null));
            const newHands = { ...hands, [PLAYER_SENTE]: [...hands[PLAYER_SENTE]], [PLAYER_GOTE]: [...hands[PLAYER_GOTE]] };
            
            let mustPromote = false;
            let canPromote = false;
            let movedPieceObj = null;

            if (from.type === 'board') {
              movedPieceObj = newBoard[from.r][from.c];
              newBoard[from.r][from.c] = null;
              
              if (newBoard[toR][toC] !== null) {
                const capturedPiece = newBoard[toR][toC];
                newHands[turn].push({ 
                  type: capturedPiece.type, 
                  owner: turn, 
                  promoted: false 
                });
              }

              const isSente = turn === PLAYER_SENTE;
              const isInZone = isSente ? toR <= 2 : toR >= 6;
              const wasInZone = isSente ? from.r <= 2 : from.r >= 6;
              
              if (movedPieceObj.type !== PIECE_TYPES.OU && movedPieceObj.type !== PIECE_TYPES.KI && !movedPieceObj.promoted) {
                if (isInZone || wasInZone) {
                  canPromote = true;
                  if (movedPieceObj.type === PIECE_TYPES.FU || movedPieceObj.type === PIECE_TYPES.KY) {
                    if ((isSente && toR === 0) || (!isSente && toR === 8)) mustPromote = true;
                  } else if (movedPieceObj.type === PIECE_TYPES.KE) {
                    if ((isSente && toR <= 1) || (!isSente && toR >= 7)) mustPromote = true;
                  }
                }
              }
            } else {
              movedPieceObj = { ...from.piece, owner: turn };
              newHands[turn].splice(from.index, 1);
            }

            newBoard[toR][toC] = movedPieceObj;

            if (mustPromote) {
              movedPieceObj.promoted = true;
              finalizeMove(newBoard, newHands, toR, toC, from.type === 'board' ? {r: from.r, c: from.c} : null);
            } else if (canPromote && from.type === 'board') {
              setPromotionPending({ 
                board: newBoard, 
                hands: newHands, 
                r: toR, 
                c: toC, 
                prev: {r: from.r, c: from.c} 
              });
              setLastMove({ from: {r: from.r, c: from.c}, to: {r: toR, c: toC} });
            } else {
              finalizeMove(newBoard, newHands, toR, toC, from.type === 'board' ? {r: from.r, c: from.c} : null);
            }
          };

          const finalizeMove = (newBoard, newHands, toR, toC, prevPos) => {
            setBoard(newBoard);
            setHands(newHands);
            setTurn(turn === PLAYER_SENTE ? PLAYER_GOTE : PLAYER_SENTE);
            setSelected(null);
            setValidDestinations([]);
            setLastMove({ from: prevPos, to: { r: toR, c: toC } });
            setPromotionPending(null);
          };

          const handlePromotionChoice = (shouldPromote) => {
            if (!promotionPending) return;
            const { board: savedBoard, hands: savedHands, r, c, prev } = promotionPending;
            const finalBoard = savedBoard.map(row => row.map(cell => cell ? {...cell} : null));

            if (shouldPromote) {
              finalBoard[r][c].promoted = true;
            }
            finalizeMove(finalBoard, savedHands, r, c, prev);
          };

          const resetGame = () => {
            if (window.confirm('ゲームをリセットしますか？')) {
              setBoard(createInitialBoard());
              setTurn(PLAYER_SENTE);
              setHands({ [PLAYER_SENTE]: [], [PLAYER_GOTE]: [] });
              setSelected(null);
              setValidDestinations([]);
              setLastMove(null);
              setPromotionPending(null);
              setMovingPiece(null);
            }
          };

          return (
            <div className="h-dvh w-full bg-zinc-50 text-zinc-800 flex flex-col items-center justify-between py-4 font-sans select-none overflow-hidden touch-none relative">
              
              {/* Menu (Floating Right Center) - タブレットでの誤操作を防ぎつつアクセスしやすい配置 */}
              <div className="absolute right-0 top-1/2 -translate-y-1/2 flex flex-col gap-2 p-2 z-40">
                  <div className="writing-vertical-rl text-[10px] text-zinc-300 tracking-widest uppercase mb-2 opacity-50">Modern Shogi DX2</div>
                  <button onClick={resetGame} className="p-3 bg-white/80 backdrop-blur shadow-md hover:bg-zinc-100 rounded-full transition-colors text-zinc-500 hover:text-zinc-900 border border-zinc-200">
                     <RotateCcw size={20} />
                  </button>
              </div>

              {/* Top: Gote (Top) - Rotated 180 deg for Face-to-Face Play */}
              <div className="w-full flex justify-center rotate-180 transition-transform duration-500">
                  <div className="flex flex-col items-center gap-2 w-full max-w-[320px] sm:max-w-md">
                      <div className={`
                         flex items-center gap-2 px-4 py-1 border rounded-full text-xs tracking-wide transition-colors
                         ${turn === PLAYER_GOTE ? 'border-zinc-800 bg-zinc-800 text-white' : 'border-zinc-300 text-zinc-400'}
                      `}>
                         <span className="w-1.5 h-1.5 rounded-full bg-current"></span>
                         PLAYER GOTE
                      </div>
                      <ModernHand 
                        owner={PLAYER_GOTE} 
                        pieces={hands[PLAYER_GOTE]} 
                        isTurn={turn === PLAYER_GOTE}
                        onPieceClick={handleHandClick}
                        selected={selected}
                        align="center"
                      />
                  </div>
              </div>

              {/* Center: Board */}
              <div className="flex-1 flex items-center justify-center w-full px-2" ref={boardRef}>
                   <div className="relative p-2 sm:p-3 bg-white shadow-xl border border-zinc-200 rounded-sm">
                     {/* Grid Lines Overlay */}
                     <div className="grid grid-cols-9 gap-0 border-2 border-zinc-900 bg-zinc-900">
                       {board.map((row, r) => (
                         row.map((cell, c) => {
                           const isSelected = selected && selected.type === 'board' && selected.r === r && selected.c === c;
                           const isValidDest = validDestinations.some(m => m.r === r && m.c === c);
                           const isLastMoveSrc = lastMove && lastMove.from && lastMove.from.r === r && lastMove.from.c === c;
                           const isLastMoveDst = lastMove && lastMove.to.r === r && lastMove.to.c === c;
                           const isMovingSource = movingPiece && movingPiece.fromPos !== 'hand' && movingPiece.fromPos.r === r && movingPiece.fromPos.c === c;
                           const showPiece = cell && !isMovingSource;

                           return (
                             <div 
                               key={`${r}-${c}`}
                               ref={el => { if (cellRefs.current[r]) cellRefs.current[r][c] = el; }}
                               className={`
                                 w-[min(10vw,36px)] h-[min(11vw,40px)] sm:w-[min(10vw,48px)] sm:h-[min(11vw,52px)] md:w-14 md:h-16
                                 bg-white flex items-center justify-center relative
                                 border-[0.5px] border-zinc-300
                                 ${isValidDest ? 'cursor-pointer' : ''}
                               `}
                               onClick={() => handleSquareClick(r, c)}
                             >
                               {/* Highlights */}
                               {isLastMoveSrc && <div className="absolute inset-0 bg-zinc-100" />}
                               {isLastMoveDst && <div className="absolute inset-0 bg-zinc-100" />}
                               {isSelected && <div className="absolute inset-0 ring-inset ring-2 ring-zinc-400 bg-zinc-50" />}
                               
                               {isValidDest && (
                                 <div className="absolute inset-0 flex items-center justify-center z-20">
                                   <div className={`rounded-full ${cell ? 'w-full h-full border-2 border-rose-400 opacity-60' : 'w-1.5 h-1.5 bg-rose-400 opacity-60'}`}></div>
                                 </div>
                               )}

                               {showPiece && (
                                 <ModernPiece 
                                   type={cell.type} 
                                   owner={cell.owner} 
                                   promoted={cell.promoted}
                                 />
                               )}
                             </div>
                           );
                         })
                       ))}
                     </div>
                   </div>

                   {/* Promotion Modal */}
                   {promotionPending && (
                     <div className="absolute inset-0 z-50 flex items-center justify-center bg-white/80 backdrop-blur-sm rounded-sm">
                       <div className="flex flex-col items-center gap-6 animate-in fade-in zoom-in duration-200 p-8 border border-zinc-200 shadow-2xl bg-white rounded-lg">
                         <p className="text-sm uppercase tracking-widest text-zinc-500">Promote?</p>
                         <div className="flex gap-8">
                           <button 
                             onClick={() => handlePromotionChoice(true)}
                             className="group flex flex-col items-center gap-2"
                           >
                             <div className="w-16 h-16 flex items-center justify-center border border-zinc-200 rounded group-hover:border-rose-400 transition-colors">
                                <ModernPiece type={PROMOTED_TYPES[promotionPending.board[promotionPending.r][promotionPending.c].type] || promotionPending.board[promotionPending.r][promotionPending.c].type} owner={turn} promoted={true} size="large" />
                             </div>
                             <span className="text-xs font-bold text-zinc-400 group-hover:text-rose-500">YES</span>
                           </button>
                           <button 
                             onClick={() => handlePromotionChoice(false)}
                             className="group flex flex-col items-center gap-2"
                           >
                             <div className="w-16 h-16 flex items-center justify-center border border-zinc-200 rounded group-hover:border-zinc-400 transition-colors">
                                <ModernPiece type={promotionPending.board[promotionPending.r][promotionPending.c].type} owner={turn} promoted={false} size="large" />
                             </div>
                             <span className="text-xs font-bold text-zinc-400 group-hover:text-zinc-800">NO</span>
                           </button>
                         </div>
                       </div>
                     </div>
                   )}

                   {/* Flying Piece Layer */}
                   {movingPiece && (
                     <FlyingPiece 
                       piece={movingPiece.piece}
                       startRect={movingPiece.startRect}
                       endRect={movingPiece.endRect}
                       onComplete={onAnimationComplete}
                     />
                   )}
              </div>

              {/* Bottom: Sente (Bottom) */}
              <div className="w-full flex justify-center">
                  <div className="flex flex-col items-center gap-2 w-full max-w-[320px] sm:max-w-md">
                      <div className={`
                         flex items-center gap-2 px-4 py-1 border rounded-full text-xs tracking-wide transition-colors
                         ${turn === PLAYER_SENTE ? 'border-zinc-800 bg-zinc-800 text-white' : 'border-zinc-300 text-zinc-400'}
                      `}>
                         <span className="w-1.5 h-1.5 rounded-full bg-current"></span>
                         PLAYER SENTE
                      </div>
                      <ModernHand 
                        owner={PLAYER_SENTE} 
                        pieces={hands[PLAYER_SENTE]} 
                        isTurn={turn === PLAYER_SENTE}
                        onPieceClick={handleHandClick}
                        selected={selected}
                        align="center"
                      />
                  </div>
              </div>

            </div>
          );
        }

        const FlyingPiece = ({ piece, startRect, endRect, onComplete }) => {
          const [style, setStyle] = useState({
            position: 'fixed',
            top: startRect.top,
            left: startRect.left,
            width: startRect.width,
            height: startRect.height,
            transform: 'scale(1)',
            zIndex: 100,
            pointerEvents: 'none',
            transition: 'all 0.3s cubic-bezier(0.25, 1, 0.5, 1)',
            opacity: 1,
            // アニメーション中の駒の位置ズレを修正するためにFlex配置を追加
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          });

          useEffect(() => {
            const timer1 = requestAnimationFrame(() => {
              setStyle(prev => ({
                ...prev,
                top: endRect.top,
                left: endRect.left,
                width: endRect.width,
                height: endRect.height,
                transform: 'scale(1.1)', 
                filter: 'drop-shadow(0px 10px 15px rgba(0,0,0,0.1))'
              }));
            });
            
            const timer2 = setTimeout(() => {
              setStyle(prev => ({ ...prev, transform: 'scale(1)', filter: 'none' }));
              setTimeout(onComplete, 50);
            }, 300);

            return () => { cancelAnimationFrame(timer1); clearTimeout(timer2); };
          }, [endRect, onComplete]);

          return (
            <div style={style}>
              <ModernPiece type={piece.type} owner={piece.owner} promoted={piece.promoted} />
            </div>
          );
        };

        function ModernHand({ owner, pieces, isTurn, onPieceClick, selected, align = 'center' }) {
          const grouped = {};
          pieces.forEach((p, idx) => {
            if (!grouped[p.type]) grouped[p.type] = [];
            grouped[p.type].push({ ...p, originalIndex: idx });
          });

          return (
            <div className={`
              w-full min-h-[72px]
              flex flex-wrap gap-2 content-center items-center justify-center
              px-4 py-2 border border-zinc-200 bg-white shadow-sm rounded-md
            `}>
              {Object.keys(grouped).length === 0 && (
                <span className="text-zinc-300 text-[10px] tracking-widest uppercase">No Pieces</span>
              )}

              {Object.entries(grouped).map(([type, list]) => {
                const piece = list[0];
                const count = list.length;
                const isSelected = selected && selected.type === 'hand' && selected.piece.type === type && pieces[selected.index].owner === owner;

                return (
                  <button 
                    key={type}
                    disabled={!isTurn}
                    onClick={(e) => onPieceClick(owner, piece.originalIndex, piece, e)}
                    className={`
                      relative flex items-center justify-center p-0.5
                      transition-all duration-200
                      ${isSelected ? 'scale-110 opacity-100' : 'opacity-80 hover:opacity-100 hover:scale-105'}
                    `}
                  >
                    <div className={`relative ${isSelected ? 'drop-shadow-lg' : 'drop-shadow-sm'}`}>
                        <ModernPiece 
                            type={type} 
                            owner={owner} 
                            promoted={false} 
                            size="small" 
                        />
                    </div>
                    {count > 1 && (
                      <span className="absolute -bottom-1 -right-1 bg-zinc-800 text-white text-[9px] font-medium px-1.5 rounded-full border border-white leading-none flex items-center justify-center h-4 min-w-[16px]">
                        {count}
                      </span>
                    )}
                  </button>
                );
              })}
            </div>
          );
        }

        // Render to #root
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ModernShogi />);
    </script>
</body>
</html>