<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Shogi DX - Refactored</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Global Styles -->
    <style>
        /* --- Base & Reset --- */
        body {
            background-color: #fafafa;
            color: #18181b;
            touch-action: manipulation;
            overscroll-behavior: none;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }
        
        .h-dvh {
            height: 100vh;
            height: 100dvh;
        }

        /* --- Animations --- */
        @keyframes rainbow-spin {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        @keyframes select-pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.2); }
            70% { box-shadow: 0 0 0 6px rgba(0, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0); }
        }
        @keyframes danger-pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
        }
        @keyframes cut-in-enter {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; filter: blur(10px); }
            50% { transform: scale(1.2) rotate(5deg); opacity: 1; filter: blur(0px); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes cut-in-exit {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; filter: blur(20px); }
        }
        @keyframes explosion-shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -5px); }
        }
        @keyframes metal-shine {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Effect Classes */
        @keyframes explosion-flash { 0% { background-color: rgba(239, 68, 68, 0.8); } 100% { background-color: transparent; } }
        .explosion-fade { animation: explosion-flash 0.8s ease-out forwards; }

        @keyframes split-flash { 0% { background-color: rgba(59, 130, 246, 0.8); } 100% { background-color: transparent; } }
        .split-fade { animation: split-flash 0.8s ease-out forwards; }

        @keyframes wind-flash { 0% { background-color: rgba(14, 165, 233, 0.5); transform: translateY(0); } 50% { transform: translateY(5px); } 100% { background-color: transparent; transform: translateY(0); } }
        .wind-fade { animation: wind-flash 0.6s ease-out forwards; }

        /* --- Container Queries for Responsive Text --- */
        .piece-container {
            container-type: size;
            width: 100%;
            height: 100%;
        }
        .piece-text-wrapper {
            font-size: 42cqh;
            line-height: 1;
        }
        .piece-text-wrapper.long-text {
            font-size: 28cqh;
            gap: 0; 
        }
        .piece-container.small .piece-text-wrapper {
             font-size: 50cqh;
        }
        .piece-container.small .piece-text-wrapper.long-text {
             font-size: 35cqh;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback, useReducer } = React;

        /* =========================================
           1. CONSTANTS & CONFIGURATION
           ========================================= */
        
        const PLAYERS = {
            SENTE: 'sente',
            GOTE: 'gote'
        };

        const RARITY = {
            SSR: 'SSR',
            SR: 'SR',
            R: 'Rare',
            C: 'Common',
            HOLE: 'HOLE' // Special type for holes
        };

        // --- Move Definitions ---
        const MOVES = {
            FRONT: { dr: -1, dc: 0 },
            BACK: { dr: 1, dc: 0 },
            SIDE: [{ dr: 0, dc: -1 }, { dr: 0, dc: 1 }],
            DIAG_FRONT: [{ dr: -1, dc: -1 }, { dr: -1, dc: 1 }],
            DIAG_BACK: [{ dr: 1, dc: -1 }, { dr: 1, dc: 1 }],
            KEIMA: [{ dr: -2, dc: -1 }, { dr: -2, dc: 1 }],
            BACK_KEIMA: [{ dr: 2, dc: -1 }, { dr: 2, dc: 1 }], 
        };

        const MOVE_SETS = {
            GOLD: [MOVES.FRONT, MOVES.BACK, ...MOVES.SIDE, ...MOVES.DIAG_FRONT], 
            SILVER: [MOVES.FRONT, ...MOVES.DIAG_FRONT, ...MOVES.DIAG_BACK],
            KING: [MOVES.FRONT, MOVES.BACK, ...MOVES.SIDE, ...MOVES.DIAG_FRONT, ...MOVES.DIAG_BACK],
            ROOK: [MOVES.FRONT, MOVES.BACK, ...MOVES.SIDE],
            BISHOP: [...MOVES.DIAG_FRONT, ...MOVES.DIAG_BACK],
        };

        // --- Piece Registry (EDIT HERE to add/modify pieces) ---
        const PIECE_REGISTRY = {
            FU: { 
                id: 'FU', name: 'æ­©å…µ', promotedName: 'ã¨é‡‘', rarity: RARITY.C, 
                moves: [MOVES.FRONT], 
                promotedMoves: MOVE_SETS.GOLD 
            },
            NH: { 
                id: 'NH', name: 'äºŒæ­©', promotedName: 'ãƒˆ', rarity: RARITY.C, 
                moves: [MOVES.FRONT], 
                promotedMoves: MOVE_SETS.SILVER 
            },
            SH: { 
                id: 'SH', name: 'æ§å…µ', promotedName: 'é‡‘æ§', rarity: RARITY.C, 
                moves: [MOVES.FRONT], 
                promotedMoves: MOVE_SETS.GOLD, 
                isLancer: true // Special Property
            },
            FS: { 
                id: 'FS', name: 'ä¸æ­£', promotedName: 'éé‡‘', rarity: RARITY.C, 
                moves: [MOVES.FRONT, MOVES.BACK], 
                promotedMoves: MOVE_SETS.GOLD,
                skill: { type: 'CORRUPTION', amount: 5 } // Special Skill
            },
            KY: { 
                id: 'KY', name: 'é¦™è»Š', promotedName: 'æˆé¦™', rarity: RARITY.R, 
                moves: [{ ...MOVES.FRONT, continuous: true }], 
                promotedMoves: MOVE_SETS.GOLD 
            },
            KE: { 
                id: 'KE', name: 'æ¡‚é¦¬', promotedName: 'æˆæ¡‚', rarity: RARITY.R, 
                moves: MOVES.KEIMA, 
                promotedMoves: MOVE_SETS.GOLD 
            },
            KD: { 
                id: 'KD', name: 'æ¡‚é¨³', promotedName: 'é€†é¨³', rarity: RARITY.R, 
                moves: MOVES.KEIMA, 
                promotedMoves: [...MOVES.KEIMA, ...MOVES.BACK_KEIMA], 
                isSplitter: true 
            },
            // NEW: Trouble Maker (åŽ„ä»‹è€…)
            TR: {
                id: 'TR', name: 'åŽ„ä»‹', promotedName: 'ä¾µç•¥', rarity: RARITY.C,
                moves: [MOVES.FRONT], // æ­©ã¨åŒã˜
                promotedMoves: MOVE_SETS.GOLD, // é‡‘ã¨åŒã˜
                skill: { type: 'BRAINWASH', maxCharges: 1 } // æˆã£ãŸå¾Œã®ã¿æœ‰åŠ¹ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ 
            },
            // NEW: Relative Move (ç›¸å¯¾ç§»å‹•)
            RM: {
                id: 'RM', name: 'ç›¤å¤‰', promotedName: 'ç›¤ç¥ž', rarity: RARITY.R,
                moves: MOVE_SETS.KING,
                promotedMoves: MOVE_SETS.KING.map(m => ({ ...m, continuous: true, limit: 2 })), // å…¨æ–¹å‘2ãƒžã‚¹
                skill: { type: 'BOARD_EXPANSION' },
                isUnique: true // 1æžšåˆ¶é™
            },
            // NEW: Hole Operator (è½ã¨ã—ç©´æ¥­è€…)
            HO: {
                id: 'HO', name: 'è½ç©´', promotedName: 'åº•ç„¡', rarity: RARITY.R,
                moves: MOVES.DIAG_FRONT, // æ–œã‚å‰æ–¹ã®ã¿
                promotedMoves: MOVE_SETS.GOLD,
                skill: { type: 'PITFALL', maxCharges: 1 }
            },
            // NEW: Roaring Chariot (è½Ÿè»Š)
            GO: {
                id: 'GO', name: 'è½Ÿè»Š', promotedName: 'è½Ÿè½Ÿ', rarity: RARITY.SR,
                moves: [MOVES.FRONT],
                promotedMoves: [MOVES.BACK], // æˆã‚‹ã¨å¾Œã‚ã«ã—ã‹ä¸‹ãŒã‚Œãªã„
                skill: { type: 'ROARING_CHARIOT', maxCharges: 1 },
                isRoaring: true // ç‰¹æ®Šãƒ•ãƒ©ã‚°ï¼ˆæˆã£ãŸæ™‚ã®ãƒ‘ãƒƒã‚·ãƒ–åŠ¹æžœç”¨ï¼‰
            },
            GI: { 
                id: 'GI', name: 'éŠ€å°†', promotedName: 'æˆéŠ€', rarity: RARITY.R, 
                moves: MOVE_SETS.SILVER, 
                promotedMoves: MOVE_SETS.GOLD 
            },
            KI: { 
                id: 'KI', name: 'é‡‘å°†', promotedName: null, rarity: RARITY.R, 
                moves: MOVE_SETS.GOLD, 
                promotedMoves: null 
            },
            MW: {
                id: 'MW', name: 'é€†é¢¨', promotedName: 'é¢¨è»Š', rarity: RARITY.R,
                moves: [...MOVE_SETS.ROOK],
                promotedMoves: [...MOVE_SETS.ROOK.map(m => ({...m, continuous: true}))], 
                skill: { type: 'WIND', maxCharges: 1 },
                isUnique: true
            },
            KA: { 
                id: 'KA', name: 'è§’è¡Œ', promotedName: 'é¾é¦¬', rarity: RARITY.SR, 
                moves: MOVE_SETS.BISHOP.map(m => ({...m, continuous: true})), 
                promotedMoves: [...MOVE_SETS.BISHOP.map(m => ({...m, continuous: true})), ...MOVE_SETS.ROOK] 
            },
            HI: { 
                id: 'HI', name: 'é£›è»Š', promotedName: 'é¾çŽ‹', rarity: RARITY.SR, 
                moves: MOVE_SETS.ROOK.map(m => ({...m, continuous: true})), 
                promotedMoves: [...MOVE_SETS.ROOK.map(m => ({...m, continuous: true})), ...MOVE_SETS.BISHOP] 
            },
            QU: { 
                id: 'QU', name: 'çŽ‹å¦ƒ', promotedName: null, rarity: RARITY.SR, 
                moves: MOVE_SETS.KING.map(m => ({...m, continuous: true})), 
                promotedMoves: null, 
                isBomb: true // Special Property
            },
            BM: { 
                id: 'BM', name: 'çˆ†ç”·', promotedName: null, rarity: RARITY.SR, 
                moves: MOVE_SETS.GOLD, 
                promotedMoves: MOVE_SETS.GOLD, 
                skill: { type: 'BOMBER', maxCharges: 1, reloadAmount: 2 } 
            },
            OU: { 
                id: 'OU', name: 'çŽ‹å°†', promotedName: null, rarity: RARITY.SSR, 
                moves: MOVE_SETS.KING, 
                promotedMoves: null 
            },
        };

        const DEFAULT_HANDS = { [PLAYERS.SENTE]: [], [PLAYERS.GOTE]: [] };

        /* =========================================
           2. HELPER FUNCTIONS (PURE LOGIC)
           ========================================= */

        const getPieceInfo = (type) => PIECE_REGISTRY[type] || PIECE_REGISTRY.FU;

        // Random Generation Logic
        const getRandomPiece = (targetRarity, uniqueCheck) => {
            let candidates = Object.values(PIECE_REGISTRY).filter(p => p.rarity === targetRarity);
            if (uniqueCheck) candidates = candidates.filter(p => !p.isUnique || !uniqueCheck[p.id]);
            if (candidates.length === 0) return 'FU';
            
            const picked = candidates[Math.floor(Math.random() * candidates.length)];
            if (picked.isUnique && uniqueCheck) uniqueCheck[picked.id] = true;
            return picked.id;
        };

        const createInitialBoard = () => {
          const board = Array(9).fill(null).map(() => Array(9).fill(null));
          const uniqueCheck = {}; 
          const place = (row, col, type, owner) => { 
              const info = PIECE_REGISTRY[type];
              const charges = info.skill ? info.skill.maxCharges : 0;
              board[row][col] = { type, owner, promoted: false, skillCharges: charges }; 
          };
          const setupSide = (owner) => {
              const isSente = owner === PLAYERS.SENTE;
              const rowCommon = isSente ? 6 : 2;
              const rowRare = isSente ? 8 : 0;
              const rowSR = isSente ? 7 : 1;
              const rowSSR = isSente ? 8 : 0; 
              for (let c = 0; c < 9; c++) place(rowCommon, c, getRandomPiece(RARITY.C, uniqueCheck), owner);
              [0, 1, 2, 3, 5, 6, 7, 8].forEach(c => place(rowRare, c, getRandomPiece(RARITY.R, uniqueCheck), owner));
              [1, 7].forEach(c => place(rowSR, c, getRandomPiece(RARITY.SR, uniqueCheck), owner));
              place(rowSSR, 4, getRandomPiece(RARITY.SSR, uniqueCheck), owner);
          };
          setupSide(PLAYERS.GOTE);
          setupSide(PLAYERS.SENTE);
          return board;
        };

        // Move Validation Logic
        const getPieceMoves = (piece, r, c, board) => {
          const moves = [];
          const isSente = piece.owner === PLAYERS.SENTE;
          const info = getPieceInfo(piece.type);
          let activeMoves = piece.promoted && info.promotedMoves ? info.promotedMoves : info.moves;
          if (!Array.isArray(activeMoves)) activeMoves = [activeMoves];

          const rows = board.length;
          const cols = board[0].length;

          activeMoves.forEach(moveDef => {
              const dr = isSente ? moveDef.dr : -moveDef.dr;
              const dc = isSente ? moveDef.dc : -moveDef.dc;
              const continuous = moveDef.continuous;
              const limit = moveDef.limit || 99; // New limit property

              let nr = r + dr;
              let nc = c + dc;
              let steps = 0;

              if (!continuous) {
                  if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                      const target = board[nr][nc];
                      if (target && target.isObstacle) return; 
                      if (target === null || target.owner !== piece.owner) moves.push({ r: nr, c: nc });
                  }
                  return;
              }

              while (nr >= 0 && nr < rows && nc >= 0 && nc < cols && steps < limit) {
                  const target = board[nr][nc];
                  if (target && target.isObstacle) break; 
                  
                  if (target === null) {
                      moves.push({ r: nr, c: nc });
                  } else {
                      if (target.owner !== piece.owner) moves.push({ r: nr, c: nc });
                      break; 
                  }
                  nr += dr;
                  nc += dc;
                  steps++;
              }
          });
          return moves;
        };

        const getHandDropMoves = (piece, turn, board) => {
            const moves = [];
            const rows = board.length;
            const cols = board[0].length;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (board[r][c] === null) {
                        // Pawn Drop Restriction (Nifu)
                        if (piece.type === 'FU') {
                            let hasPawn = false;
                            for (let i = 0; i < rows; i++) if (board[i][c]?.owner === turn && board[i][c]?.type === 'FU' && !board[i][c].promoted) hasPawn = true;
                            if (hasPawn) continue;
                            if (turn === PLAYERS.SENTE && r === 0) continue;
                            if (turn === PLAYERS.GOTE && r === rows - 1) continue;
                        }
                        // Dead End Restrictions
                        if (['NH', 'SH', 'FS', 'KY'].includes(piece.type)) { 
                           if (turn === PLAYERS.SENTE && r === 0) continue;
                           if (turn === PLAYERS.GOTE && r === rows - 1) continue;
                        }
                        if (['KE', 'KD', 'HO'].includes(piece.type)) { 
                           if (['KE', 'KD'].includes(piece.type)) {
                               if (turn === PLAYERS.SENTE && r <= 1) continue;
                               if (turn === PLAYERS.GOTE && r >= rows - 2) continue;
                           }
                           if (piece.type === 'HO') {
                               if (turn === PLAYERS.SENTE && r === 0) continue;
                               if (turn === PLAYERS.GOTE && r === rows - 1) continue;
                           }
                        }
                        moves.push({ r, c });
                    }
                }
            }
            return moves;
        };

        /* =========================================
           3. UI COMPONENTS
           ========================================= */

        // --- Icons ---
        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
        );
        const Crosshair = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></svg>
        );

        // --- Modern Background ---
        const ModernBackground = ({ isSkillMode }) => (
            <div className="absolute inset-0 z-0 overflow-hidden pointer-events-none bg-zinc-50 transition-colors duration-500">
                <div className="absolute inset-0 opacity-20"
                    style={{ backgroundImage: 'linear-gradient(#cbd5e1 1px, transparent 1px), linear-gradient(90deg, #cbd5e1 1px, transparent 1px)', backgroundSize: '40px 40px' }}
                ></div>
                <div className={`absolute inset-0 bg-red-500/10 pointer-events-none transition-opacity duration-300 ${isSkillMode ? 'opacity-100' : 'opacity-0'}`}></div>
                <div className="absolute inset-0 bg-gradient-to-b from-white/0 via-white/50 to-white/0 pointer-events-none"></div>
            </div>
        );

        // --- CutIn Effect ---
        const CutInOverlay = ({ type, text, subText, onComplete }) => {
            const [exiting, setExiting] = useState(false);
            useEffect(() => {
                const timer = setTimeout(() => {
                    setExiting(true);
                    setTimeout(onComplete, 400); 
                }, 1200); 
                return () => clearTimeout(timer);
            }, [onComplete]);

            const colorClass = 
                type === 'CORRUPTION' ? 'text-purple-600 drop-shadow-xl from-purple-800 to-pink-600' :
                type === 'WIND' ? 'text-sky-500 drop-shadow-xl from-sky-400 to-indigo-500' :
                type === 'SPLIT' ? 'text-cyan-500 drop-shadow-xl from-blue-400 to-cyan-300' :
                type === 'BOMB_SKILL' ? 'text-orange-500 drop-shadow-xl from-red-500 to-yellow-500' :
                type === 'EXPLOSION' ? 'text-red-600 drop-shadow-xl' :
                type === 'PITFALL' ? 'text-zinc-800 drop-shadow-xl from-black to-zinc-600' :
                type === 'ROAR' ? 'text-red-700 drop-shadow-xl from-red-900 to-orange-600' : 
                type === 'EXPANSION' ? 'text-teal-500 drop-shadow-xl from-teal-400 to-emerald-600' :
                type === 'BRAINWASH' ? 'text-fuchsia-600 drop-shadow-xl from-fuchsia-500 to-purple-800' :
                type === 'TROUBLE' ? 'text-violet-600 drop-shadow-xl from-violet-500 to-indigo-800' :
                type === 'CHECK' ? 'text-rose-600 drop-shadow-xl' :
                type === 'PROMOTION' ? 'text-amber-500 drop-shadow-xl' :
                type === 'CAPTURE' ? 'text-blue-600 drop-shadow-xl' :
                'text-zinc-800 drop-shadow-xl';

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center pointer-events-none perspective-1000">
                    <div className={`absolute inset-0 bg-white/60 transition-opacity duration-300 ${exiting ? 'opacity-0' : 'opacity-100'}`} />
                    <div className={`relative flex flex-col items-center justify-center ${exiting ? 'animate-[cut-in-exit_0.4s_forwards]' : 'animate-[cut-in-enter_0.4s_cubic-bezier(0.17,0.67,0.83,0.67)]'}`}>
                         <h2 className={`text-6xl md:text-8xl font-black italic tracking-tighter ${colorClass} transform -skew-x-12 border-white`}>{text}</h2>
                         {subText && <p className="mt-2 text-xl md:text-2xl font-bold text-zinc-500 tracking-widest uppercase transform -skew-x-12">{subText}</p>}
                    </div>
                </div>
            );
        };

        // --- Modern Piece Component ---
        const ModernPiece = ({ type, owner, promoted, charges, size = 'large', style = {}, isSelected = false, isFrozen = false }) => {
          const isGote = owner === PLAYERS.GOTE;
          const info = getPieceInfo(type);
          const name = promoted && info.promotedName ? info.promotedName : info.name;
          const rarity = info.rarity;
          const pentagonPath = 'polygon(50% 0%, 82% 25%, 92% 100%, 8% 100%, 18% 25%)';
          const chars = name.split('');

          // Style definitions based on rarity
          let styles = {
             borderColor: 'bg-slate-500', // Common: Metallic Grey Border
             textColor: 'text-slate-600', // Common: Metallic Grey Text
             glowColor: 'drop-shadow-sm',
             innerBackground: 'bg-white',   // Common: White Background
             animationClass: ''
          };

          if (rarity === RARITY.SSR) {
              styles = { 
                  borderColor: 'transparent', // Handled by rainbow gradient below
                  // SSR: White Text
                  textColor: 'text-white font-black drop-shadow-sm', 
                  glowColor: 'drop-shadow-[0_0_5px_rgba(255,255,255,0.5)]', 
                  animationClass: 'animate-[rainbow-spin_4s_linear_infinite]', 
                  // SSR: Metallic Grey Fill
                  innerBackground: 'bg-gradient-to-br from-slate-200 via-slate-400 to-slate-500 border border-white/20' 
              };
          } else if (rarity === RARITY.SR) {
              styles = { 
                  borderColor: 'bg-red-600', // SR: Red Line Art
                  textColor: 'text-red-600', 
                  glowColor: 'drop-shadow-[0_2px_4px_rgba(220,38,38,0.2)]',
                  innerBackground: 'bg-white'
              };
          } else if (rarity === RARITY.R) {
              styles = { 
                  borderColor: 'bg-blue-600', // Rare: Blue Line Art
                  textColor: 'text-blue-600', 
                  glowColor: 'drop-shadow-[0_2px_4px_rgba(37,99,235,0.2)]',
                  innerBackground: 'bg-white'
              };
          }
          
          if (promoted && rarity !== RARITY.SSR) styles.textColor = 'text-rose-600';

          return (
            <div 
              className={`piece-container ${size === 'small' ? 'small' : ''} relative flex flex-col items-center justify-center select-none font-serif font-bold transition-transform duration-300 ${size === 'large' ? 'h-[92%]' : 'h-8'} ${isSelected ? 'z-20 scale-110' : 'z-10'} ${styles.glowColor}`}
              style={{ transform: isGote ? 'rotate(180deg)' : 'rotate(0deg)', aspectRatio: '1 / 1', ...style }}
            >
              {isSelected && <div className="absolute inset-[-6px] border-2 border-slate-400 rounded-full animate-[select-pulse_1s_infinite]" style={{ clipPath: pentagonPath }} />}
              
              {isFrozen && <div className="absolute inset-[-8px] z-40 bg-cyan-300/30 backdrop-blur-[1px] border-2 border-cyan-400/50 rounded-full animate-pulse pointer-events-none" style={{ clipPath: pentagonPath }}></div>}

              <div className={`absolute inset-0 ${styles.borderColor}`} style={{ clipPath: pentagonPath, background: rarity === RARITY.SSR ? 'conic-gradient(from 0deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000)' : undefined }}>
                 {rarity === RARITY.SSR && <div className={`absolute inset-[-50%] w-[200%] h-[200%] ${styles.animationClass}`} style={{ background: 'inherit' }} />}
              </div>
              
              <div className={`absolute inset-[2px] z-10 ${styles.innerBackground}`} style={{ clipPath: pentagonPath }}>
                  {rarity === RARITY.SSR && <div className="absolute inset-0 opacity-30 bg-gradient-to-tr from-transparent via-white to-transparent animate-[metal-shine_3s_infinite_linear] bg-[length:200%_100%]"></div>}
              </div>
              
              <div className={`relative z-20 flex flex-col items-center justify-center piece-text-wrapper ${chars.length > 1 ? 'long-text' : ''} ${styles.textColor} ${size === 'large' ? 'pt-[5%]' : 'pt-[2%]'}`}>
                {chars.map((char, i) => <span key={i} style={{ fontSize: '1em' }}>{char}</span>)}
              </div>
              
              {charges > 0 && size === 'large' && (
                  <div className="absolute -bottom-1 -right-1 z-30 flex gap-0.5">
                      {[...Array(charges)].map((_, i) => <div key={i} className="w-2 h-2 rounded-full bg-red-500 border border-white shadow-sm"></div>)}
                  </div>
              )}
            </div>
          );
        };

        const FlyingPiece = ({ piece, startRect, endRect, onComplete }) => {
          const [style, setStyle] = useState({
            position: 'fixed', top: startRect.top, left: startRect.left, width: startRect.width, height: startRect.height,
            transform: 'scale(1)', zIndex: 100, pointerEvents: 'none', transition: 'all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1)', 
            opacity: 1, display: 'flex', alignItems: 'center', justifyContent: 'center',
          });
          
          useEffect(() => {
            const timer1 = requestAnimationFrame(() => {
              setStyle(prev => ({ ...prev, top: endRect.top, left: endRect.left, width: endRect.width, height: endRect.height, transform: 'scale(1.1)', filter: 'drop-shadow(0 4px 6px rgba(0,0,0,0.1))' }));
            });
            const timer2 = setTimeout(() => {
              setStyle(prev => ({ ...prev, transform: 'scale(1)', filter: 'none' }));
              setTimeout(onComplete, 50);
            }, 400);
            return () => { cancelAnimationFrame(timer1); clearTimeout(timer2); };
          }, [endRect, onComplete]);

          return <div style={style}><ModernPiece type={piece.type} owner={piece.owner} promoted={piece.promoted} /></div>;
        };

        function ModernHand({ owner, pieces, isTurn, onPieceClick, selected }) {
          const grouped = {};
          pieces.forEach((p, idx) => {
            if (!grouped[p.type]) grouped[p.type] = [];
            grouped[p.type].push({ ...p, originalIndex: idx });
          });

          return (
            <div className={`w-full min-h-[72px] flex flex-wrap gap-2 content-center items-center justify-center px-4 py-2 bg-white rounded-lg border border-zinc-200 shadow-sm`}>
              {Object.keys(grouped).length === 0 && <span className="text-zinc-300 text-[10px] tracking-widest uppercase">No Pieces</span>}
              {Object.entries(grouped).map(([type, list]) => {
                const piece = list[0];
                const count = list.length;
                const isSelected = selected && selected.type === 'hand' && selected.piece.type === type && pieces[selected.index].owner === owner;
                return (
                  <button key={type} disabled={!isTurn} onClick={(e) => onPieceClick(owner, piece.originalIndex, piece, e)} className={`relative flex items-center justify-center p-0.5 transition-all duration-200 ${isSelected ? 'scale-110 opacity-100' : 'opacity-80 hover:opacity-100 hover:scale-105'}`}>
                    <div className={`relative w-8 h-8`}><ModernPiece type={type} owner={owner} promoted={false} size="small" /></div>
                    {count > 1 && <span className="absolute -bottom-1 -right-1 bg-zinc-800 text-white text-[9px] font-medium px-1.5 rounded-full border border-white leading-none flex items-center justify-center h-4 min-w-[16px]">{count}</span>}
                  </button>
                );
              })}
            </div>
          );
        }

        const PromotionModal = ({ pending, onChoice }) => (
             <div className="absolute inset-0 z-50 flex items-center justify-center bg-white/90 rounded-sm">
               <div className="flex flex-col items-center gap-6 p-8 border border-zinc-200 bg-white rounded-lg shadow-2xl">
                 <p className="text-xl font-bold tracking-widest text-zinc-800">PROMOTE?</p>
                 <div className="flex gap-8">
                   <button onClick={() => onChoice(true)} className="group flex flex-col items-center gap-2">
                     <div className="w-16 h-16 flex items-center justify-center border border-zinc-200 bg-white rounded group-hover:border-rose-500 transition-all shadow-sm">
                        <ModernPiece type={pending.board[pending.r][pending.c].type} owner={pending.turn} promoted={true} size="large" />
                     </div>
                     <span className="text-sm font-bold text-zinc-400 group-hover:text-rose-500">YES</span>
                   </button>
                   <button onClick={() => onChoice(false)} className="group flex flex-col items-center gap-2">
                     <div className="w-16 h-16 flex items-center justify-center border border-zinc-200 bg-white rounded group-hover:border-zinc-800 transition-all shadow-sm">
                        <ModernPiece type={pending.board[pending.r][pending.c].type} owner={pending.turn} promoted={false} size="large" />
                     </div>
                     <span className="text-sm font-bold text-zinc-400 group-hover:text-zinc-800">NO</span>
                   </button>
                 </div>
               </div>
             </div>
        );

        const ExplosionModal = ({ onChoice }) => (
             <div className="absolute inset-0 z-50 flex items-center justify-center bg-red-50/90 rounded-sm animate-[danger-pulse_2s_infinite]">
               <div className="flex flex-col items-center gap-6 p-8 border border-red-200 bg-white rounded-lg shadow-2xl">
                 <p className="text-2xl font-black italic tracking-widest text-red-600 animate-pulse">DETONATE?</p>
                 <p className="text-xs text-red-400 max-w-[200px] text-center">Destroy surrounding pieces (SR or lower) and sacrifice self to opponent.</p>
                 <div className="flex gap-8 mt-2">
                   <button onClick={() => onChoice(true)} className="group flex flex-col items-center gap-2">
                     <div className="w-16 h-16 flex items-center justify-center border-2 border-red-500 bg-red-50 rounded-full group-hover:scale-110 transition-all shadow-md"><span className="text-3xl">ðŸ’¥</span></div>
                     <span className="text-sm font-bold text-red-500 group-hover:text-red-600">EXPLODE</span>
                   </button>
                   <button onClick={() => onChoice(false)} className="group flex flex-col items-center gap-2">
                     <div className="w-16 h-16 flex items-center justify-center border border-zinc-200 bg-white rounded-full group-hover:border-zinc-400 transition-all shadow-sm"><span className="text-xl text-zinc-400">âœ–</span></div>
                     <span className="text-sm font-bold text-zinc-400 group-hover:text-zinc-800">CANCEL</span>
                   </button>
                 </div>
               </div>
             </div>
        );

        /* =========================================
           4. CUSTOM HOOKS (GAME LOGIC)
           ========================================= */

        const useShogiGame = () => {
            const [board, setBoard] = useState(null); 
            const [turn, setTurn] = useState(PLAYERS.SENTE);
            const [hands, setHands] = useState(DEFAULT_HANDS);
            const [selected, setSelected] = useState(null); 
            const [validDestinations, setValidDestinations] = useState([]);
            const [lastMove, setLastMove] = useState(null);
            const [cutIn, setCutIn] = useState(null);
            
            // Special States
            const [skillMode, setSkillMode] = useState(false);
            const [brainwashState, setBrainwashState] = useState(null); // { step: 'SELECT_TARGET' | 'MOVE_TARGET', targetPos: {r,c} }
            const [promotionPending, setPromotionPending] = useState(null);
            const [explosionPending, setExplosionPending] = useState(null); 
            const [movingPiece, setMovingPiece] = useState(null);

            // Effect States
            const [effects, setEffects] = useState({ explosion: [], split: [], wind: [] });

            useEffect(() => { setBoard(createInitialBoard()); }, []);

            const triggerEffect = (type, cells) => {
                setEffects(prev => ({ ...prev, [type]: cells }));
                setTimeout(() => setEffects(prev => ({ ...prev, [type]: [] })), 800);
            };

            const playSound = useCallback((type) => { /* Placeholder for sound logic */ }, []);

            // --- Move Calculation ---
            useEffect(() => {
                if (!board || !selected) {
                    setValidDestinations([]);
                    setSkillMode(false);
                    setBrainwashState(null);
                    return;
                }
                
                // Brainwash Logic
                if (brainwashState && brainwashState.step === 'MOVE_TARGET') {
                    const target = board[brainwashState.targetPos.r][brainwashState.targetPos.c];
                    // Calculate moves for the ENEMY piece as if it were moving
                    setValidDestinations(getPieceMoves(target, brainwashState.targetPos.r, brainwashState.targetPos.c, board));
                    return;
                }

                if (skillMode) { 
                    const piece = board[selected.r][selected.c];
                    if (piece.type === 'TR' && piece.promoted) {
                        // Brainwash init: no destinations yet, waiting for target click
                        setValidDestinations([]);
                        if (!brainwashState) setBrainwashState({ step: 'SELECT_TARGET' });
                    } else {
                        setValidDestinations([]); 
                    }
                    return; 
                }

                if (selected.type === 'board') {
                    const piece = board[selected.r][selected.c];
                    if (piece && piece.owner === turn) {
                        setValidDestinations(getPieceMoves(piece, selected.r, selected.c, board));
                    }
                } else if (selected.type === 'hand') {
                    setValidDestinations(getHandDropMoves(selected.piece, turn, board));
                }
            }, [selected, board, turn, skillMode, brainwashState]);

            // --- Action Handlers ---
            const handleBoardClick = (r, c, cellRefs, boardRef) => {
                if (!board || promotionPending || explosionPending || movingPiece || cutIn) return;
                const target = board[r][c];

                // 0. Brainwash Interactions
                if (skillMode && brainwashState) {
                    if (brainwashState.step === 'SELECT_TARGET') {
                        // Picking enemy to brainwash
                        if (target && target.owner !== turn && !target.isObstacle) {
                            setBrainwashState({ step: 'MOVE_TARGET', targetPos: {r, c} });
                            playSound('select');
                        }
                        return;
                    } else if (brainwashState.step === 'MOVE_TARGET') {
                        // Picking destination for brainwashed piece
                        if (validDestinations.some(m => m.r === r && m.c === c)) {
                            executeBrainwashMove(brainwashState.targetPos, r, c);
                        } else {
                            // Cancel or re-select
                            if (target && target.owner !== turn) {
                                setBrainwashState({ step: 'MOVE_TARGET', targetPos: {r, c} }); // Change target
                            } else {
                                setBrainwashState(null); setSkillMode(false); setSelected(null);
                            }
                        }
                        return;
                    }
                }

                // 1. Skill Execution (Normal)
                if (skillMode && selected && selected.type === 'board') {
                    const piece = board[selected.r][selected.c];
                    // Skip if Brainwash (handled above)
                    if (!(piece.type === 'TR' && piece.promoted)) {
                        executeSkill(selected, r, c);
                        return;
                    }
                }

                // 2. Select / Deselect Logic
                if (!selected) {
                    if (target && target.owner === turn && !target.frozen) { setSelected({ type: 'board', r, c }); playSound('select'); }
                    return;
                }
                
                // Toggle Skill Mode
                if (selected.type === 'board' && selected.r === r && selected.c === c) {
                    const piece = board[r][c];
                    const info = getPieceInfo(piece.type);
                    if (info.skill && piece.skillCharges > 0) {
                        // TR skill only if promoted
                        if (piece.type === 'TR' && !piece.promoted) {
                             setSelected(null); setSkillMode(false);
                        } else {
                             setSkillMode(!skillMode); playSound('select');
                        }
                    } else {
                        setSelected(null); setSkillMode(false);
                    }
                    return;
                }

                if (target && target.owner === turn && !target.frozen) {
                    setSelected({ type: 'board', r, c }); setSkillMode(false); setBrainwashState(null); playSound('select');
                    return;
                }

                // 3. Move Execution
                if (!skillMode && validDestinations.some(m => m.r === r && m.c === c)) {
                    prepareMoveAnimation(selected, r, c, cellRefs, boardRef);
                } else {
                    setSelected(null);
                }
            };

            const handleHandClick = (owner, index, piece) => {
                if (!board || promotionPending || explosionPending || movingPiece || cutIn || owner !== turn) return;
                if (selected && selected.type === 'hand' && selected.index === index) {
                    setSelected(null);
                } else {
                    setSelected({ type: 'hand', index, piece });
                    setSkillMode(false);
                    setBrainwashState(null);
                    playSound('select');
                }
            };

            // --- Core Logic Implementations ---
            
            const prepareMoveAnimation = (from, toR, toC, cellRefs, boardRef) => {
                let startRect = null, endRect = null, animatedPiece = null;
                
                // Calculate Rects for Animation
                if (cellRefs.current[toR]?.[toC]) endRect = cellRefs.current[toR][toC].getBoundingClientRect();
                if (from.type === 'board') {
                    if (cellRefs.current[from.r]?.[from.c]) startRect = cellRefs.current[from.r][from.c].getBoundingClientRect();
                    animatedPiece = board[from.r][from.c];
                } else {
                    if (boardRef.current) {
                        const br = boardRef.current.getBoundingClientRect();
                        startRect = { top: br.top + br.height/2 - 20, left: br.left + br.width/2 - 20, width: 40, height: 40 };
                    }
                    animatedPiece = from.piece;
                }

                if (startRect && endRect && animatedPiece) {
                    setMovingPiece({ piece: animatedPiece, fromPos: from.type === 'board' ? {r: from.r, c: from.c} : 'hand', startRect, endRect, toR, toC, fromInfo: from });
                    playSound('move_start');
                } else {
                    executeMove(from, toR, toC);
                }
            };

            const completeAnimation = () => {
                if (!movingPiece) return;
                executeMove(movingPiece.fromInfo, movingPiece.toR, movingPiece.toC);
                setMovingPiece(null);
            };

            const executeBrainwashMove = (fromPos, toR, toC) => {
                const newBoard = board.map(r => r.map(c => c ? {...c} : null));
                const newHands = { ...hands, [PLAYERS.SENTE]: [...hands[PLAYERS.SENTE]], [PLAYERS.GOTE]: [...hands[PLAYERS.GOTE]] };
                
                const target = newBoard[fromPos.r][fromPos.c];
                
                // Consume Charge
                if (selected && selected.type === 'board') {
                    newBoard[selected.r][selected.c].skillCharges -= 1;
                }

                // Handle Capture (by the brainwashed piece)
                if (newBoard[toR][toC]) {
                    const captured = newBoard[toR][toC];
                    // Captured piece goes to ME (the one who brainwashed), or the OWNER of the piece?
                    // "ä¸€å›žå‹æ‰‹ã«æ“ä½œã™ã‚‹" -> Usually the controller gets the benefit.
                    // Let's give it to the brainwasher (current turn).
                    const tInfo = getPieceInfo(captured.type);
                    newHands[turn].push({ type: captured.type, owner: turn, promoted: false, skillCharges: tInfo.skill?.maxCharges || 0 });
                    
                    // TR Check for the captured piece?
                    // If I brainwash enemy A to kill enemy B (TR).
                    // Enemy B dies. Enemy B (TR) effect triggers: "Attacker becomes mine".
                    // Attacker is Enemy A. Enemy A changes owner to Enemy B's owner.
                    // They are same owner usually. So no effect.
                    // If I brainwash enemy A to kill MY piece B (TR).
                    // My piece B (TR) dies. Attacker (Enemy A) becomes MY piece.
                    if (captured.type === 'TR' && !captured.promoted) {
                        target.owner = captured.owner; // Betrayal logic
                    }
                }

                // Move
                newBoard[fromPos.r][fromPos.c] = null;
                newBoard[toR][toC] = target;
                target.frozen = true; // Freeze for next turn

                setCutIn({ type: 'BRAINWASH', text: 'BRAINWASH', subText: 'PUPPET MOVE' });
                
                updateGameState(newBoard, newHands, {r:toR, c:toC}, fromPos);
            };

            const executeSkill = (from, targetR, targetC) => {
                const piece = board[from.r][from.c];
                const info = getPieceInfo(piece.type);
                if (!piece || piece.skillCharges <= 0) return;
                
                const newBoard = board.map(r => r.map(c => c ? {...c} : null));
                const newHands = { ...hands, [PLAYERS.SENTE]: [...hands[PLAYERS.SENTE]], [PLAYERS.GOTE]: [...hands[PLAYERS.GOTE]] };
                newBoard[from.r][from.c].skillCharges -= 1;

                if (info.skill.type === 'WIND') {
                    // Wind Logic
                    const pushDr = turn === PLAYERS.SENTE ? -1 : 1;
                    const affectedCells = [];
                    const processOrder = [];
                    const rows = newBoard.length;
                    const cols = newBoard[0].length;
                    for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) if(newBoard[r][c] && newBoard[r][c].owner !== turn) processOrder.push({r,c});
                    processOrder.sort((a,b) => pushDr === -1 ? a.r - b.r : b.r - a.r);

                    processOrder.forEach(pos => {
                        const t = newBoard[pos.r][pos.c];
                        let currR = pos.r, finalR = currR, moved = false;
                        let nextR = currR + pushDr;
                        while(nextR >= 0 && nextR < rows && newBoard[nextR][pos.c] === null) {
                            finalR = nextR; nextR += pushDr; moved = true;
                        }
                        if(moved) {
                            newBoard[finalR][pos.c] = t; newBoard[pos.r][pos.c] = null;
                            affectedCells.push({r: finalR, c: pos.c});
                        }
                    });
                    triggerEffect('wind', affectedCells);
                    setCutIn({ type: 'WIND', text: 'WIND BLAST', subText: 'REPEL' });

                } else if (info.skill.type === 'BOMBER') {
                    // Bomber Logic
                    const targets = [];
                    const rows = newBoard.length;
                    const cols = newBoard[0].length;
                    for(let i=-3; i<=3; i++) targets.push({r: targetR+i, c: targetC});
                    for(let i=-3; i<=3; i++) if(i!==0) targets.push({r: targetR, c: targetC+i});
                    triggerEffect('explosion', targets);
                    
                    targets.forEach(pos => {
                        if(pos.r>=0 && pos.r<rows && pos.c>=0 && pos.c<cols) {
                            const t = newBoard[pos.r][pos.c];
                            if(t && t.owner !== turn) {
                                const tInfo = getPieceInfo(t.type);
                                if(tInfo.rarity === RARITY.R || tInfo.rarity === RARITY.C) {
                                    newHands[turn].push({ type: t.type, owner: turn, promoted: false, skillCharges: tInfo.skill?.maxCharges || 0 });
                                    newBoard[pos.r][pos.c] = null;
                                }
                            }
                        }
                    });
                    setCutIn({ type: 'BOMB_SKILL', text: 'BOMB SET', subText: 'DESTRUCTION' });
                } else if (info.skill.type === 'PITFALL') {
                    // Pitfall Logic
                    if (newBoard[targetR][targetC] !== null) return; // Must be empty
                    
                    newBoard[targetR][targetC] = { type: 'HOLE', isObstacle: true, owner: null };
                    newBoard[from.r][from.c] = null; // Consume self
                    
                    triggerEffect('explosion', [{r: targetR, c: targetC}]);
                    setCutIn({ type: 'PITFALL', text: 'PITFALL', subText: 'VOID CREATED' });
                } else if (info.skill.type === 'ROARING_CHARIOT') {
                    // Roaring Chariot Logic
                    const rows = newBoard.length;
                    const cols = newBoard[0].length;
                    const forward = turn === PLAYERS.SENTE ? -1 : 1;
                    const startR = from.r;
                    const startC = from.c;
                    const endR = turn === PLAYERS.SENTE ? 0 : rows - 1; 
                    
                    const me = newBoard[startR][startC];
                    newBoard[startR][startC] = null;

                    // Place self at end (if not hole)
                    if (!newBoard[endR][startC]?.isObstacle) {
                        newBoard[endR][startC] = me;
                        me.promoted = true; 
                    }
                    
                    // Effect Zone: Path + 1 left/right
                    const effectCells = [];
                    const opponent = turn === PLAYERS.SENTE ? PLAYERS.GOTE : PLAYERS.SENTE;
                    
                    let currR = startR + forward;
                    while (currR !== endR + forward) {
                        for (let dc = -1; dc <= 1; dc++) { // Width 3
                            const c = startC + dc;
                            if (c >= 0 && c < cols && currR >= 0 && currR < rows) {
                                effectCells.push({r: currR, c});
                                
                                const target = newBoard[currR][c];
                                if (target && !target.isObstacle) {
                                    if (currR === endR && c === startC) {
                                       // Skip self position (handled by placement)
                                    } else {
                                        const tInfo = getPieceInfo(target.type);
                                        // Indiscriminate capture
                                        if (target.owner !== turn) {
                                            newHands[turn].push({ type: target.type, owner: turn, promoted: false, skillCharges: tInfo.skill?.maxCharges || 0 });
                                        } else {
                                            newHands[opponent].push({ type: target.type, owner: opponent, promoted: false, skillCharges: tInfo.skill?.maxCharges || 0 });
                                        }
                                        newBoard[currR][c] = null;
                                    }
                                }
                            }
                        }
                        currR += forward;
                    }

                    triggerEffect('explosion', effectCells);
                    setCutIn({ type: 'ROAR', text: 'ROARING CHARIOT', subText: 'PATH OF DESTRUCTION' });
                }
                
                updateGameState(newBoard, newHands, null, from); // Skill action doesn't move piece physically
            };

            const executeMove = (from, toR, toC) => {
                let newBoard = board.map(r => r.map(c => c ? {...c} : null));
                const newHands = { ...hands, [PLAYERS.SENTE]: [...hands[PLAYERS.SENTE]], [PLAYERS.GOTE]: [...hands[PLAYERS.GOTE]] };
                
                let pieceObj, info;
                let mustPromote = false, canPromote = false, canExplode = false, didSplit = false, captureOccurred = false;
                let boardExpanded = false;
                let troubleTriggered = false;

                // Variables for scope
                let isInZone = false;
                let wasInZone = false;
                const isSente = turn === PLAYERS.SENTE;
                const rows = newBoard.length;
                const cols = newBoard[0].length;

                // 1. Move or Drop?
                if (from.type === 'board') {
                    pieceObj = newBoard[from.r][from.c];
                    newBoard[from.r][from.c] = null;
                    info = getPieceInfo(pieceObj.type);

                    // Zone Check
                    isInZone = isSente ? toR <= 2 : toR >= rows - 3;
                    wasInZone = isSente ? from.r <= 2 : from.r >= rows - 3;

                    // Capture Logic
                    if (newBoard[toR][toC]) {
                        const captured = newBoard[toR][toC];
                        const capInfo = getPieceInfo(captured.type);
                        newHands[turn].push({ type: captured.type, owner: turn, promoted: false, skillCharges: capInfo.skill?.maxCharges || 0 });
                        captureOccurred = true;
                        
                        newBoard[toR][toC] = null;

                        // TROUBLE MAKER (TR) Logic
                        if (captured.type === 'TR' && !captured.promoted) {
                            pieceObj.owner = captured.owner; // Swaps owner!
                            troubleTriggered = true;
                        }

                        // Corruption Logic
                        if (info.skill?.type === 'CORRUPTION' && !pieceObj.promoted) {
                            const opp = turn === PLAYERS.SENTE ? PLAYERS.GOTE : PLAYERS.SENTE;
                            let count = 0;
                            for(let i=0; i<newHands[opp].length && count < info.skill.amount; i++) {
                                if(newHands[opp][i].type !== 'FU') {
                                    newHands[opp][i] = { ...newHands[opp][i], type: 'FU', promoted: false, skillCharges: 0 };
                                    count++;
                                }
                            }
                            if(count > 0) setCutIn({ type: 'CORRUPTION', text: 'CORRUPTION', subText: 'HANDS MODIFIED' });
                        }
                    }

                    // Special Checks
                    if (info.isBomb && (isInZone || wasInZone)) canExplode = true;

                    // Splitter Logic
                    if (info.isSplitter && !pieceObj.promoted) {
                        const dc = toC - from.c;
                        const otherC = from.c - dc;
                        if(otherC >= 0 && otherC < cols) {
                            const otherT = newBoard[toR][otherC];
                            if(!otherT || (!otherT.isObstacle && otherT.owner !== turn)) { 
                                if(otherT && !otherT.isObstacle) newHands[turn].push({ type: otherT.type, owner: turn, promoted: false, skillCharges: getPieceInfo(otherT.type).skill?.maxCharges||0 });
                                newBoard[toR][otherC] = { ...pieceObj };
                                didSplit = true;
                                triggerEffect('split', [{r: toR, c: otherC}]);
                            }
                        }
                    }

                    // Promotion Rules Check (Logic Preparation)
                    if (pieceObj.type !== 'OU' && pieceObj.type !== 'KI' && !pieceObj.promoted && info.promotedMoves) {
                        if (isInZone || wasInZone) {
                            canPromote = true;
                            if (['FU', 'SH', 'NH', 'FS', 'KY', 'HO'].includes(pieceObj.type) && ((isSente && toR === 0) || (!isSente && toR === rows - 1))) mustPromote = true;
                            if (['KE', 'KD'].includes(pieceObj.type) && ((isSente && toR <= 1) || (!isSente && toR >= rows - 2))) mustPromote = true;
                        }
                    }

                    // BOARD EXPANSION SKILL (RM)
                    if (info.skill?.type === 'BOARD_EXPANSION' && !pieceObj.promoted) {
                        // Check move direction
                        const dr = toR - from.r;
                        const dc = toC - from.c;
                        
                        let expandRows = (dr !== 0); // Vertical movement -> insert row
                        let expandCols = (dc !== 0); // Horizontal movement -> insert col

                        // Insert Col
                        if (expandCols) {
                             const insertC = Math.max(from.c, toC);
                             newBoard.forEach(row => row.splice(insertC, 0, null));
                             if (toC >= insertC) toC++;
                             boardExpanded = true;
                        }

                        // Insert Row
                        if (expandRows) {
                            const newRow = Array(newBoard[0].length).fill(null);
                            const insertR = Math.max(from.r, toR);
                            newBoard.splice(insertR, 0, newRow);
                            if (toR >= insertR) toR++;
                            boardExpanded = true;
                        }
                        
                        if (boardExpanded) setCutIn({ type: 'EXPANSION', text: 'BOARD EXPAND', subText: 'SPACE DISTORTION' });
                    }

                } else {
                    // Drop
                    info = getPieceInfo(from.piece.type);
                    pieceObj = { ...from.piece, owner: turn, skillCharges: info.skill?.maxCharges || 0 };
                    newHands[turn].splice(from.index, 1);
                }

                newBoard[toR][toC] = pieceObj;

                // --- Post-Move Effects ---

                // Lancer Logic
                if (info.isLancer && from.type === 'board') {
                    const fwd = turn === PLAYERS.SENTE ? -1 : 1;
                    const targets = [];
                    const currentRows = newBoard.length;
                    if(!pieceObj.promoted) { targets.push({r:toR,c:toC}); if(toR+fwd >= 0 && toR+fwd < currentRows) targets.push({r:toR+fwd,c:toC}); }
                    else { if(toR+fwd >= 0 && toR+fwd < currentRows) targets.push({r:toR+fwd,c:toC}); }
                    
                    if(targets.length>0) triggerEffect('explosion', targets);
                    targets.forEach(p => {
                        const t = newBoard[p.r][p.c];
                        if(t && !t.isObstacle && t.owner!==turn && getPieceInfo(t.type).rarity !== RARITY.SSR) { newBoard[p.r][p.c] = null; playSound('capture'); }
                    });
                }

                // Roaring Chariot (Promoted) Logic
                if (info.isRoaring && pieceObj.promoted && from.type === 'board') {
                    const targets = [];
                    const currentRows = newBoard.length;
                    const currentCols = newBoard[0].length;
                    for(let dr=-1; dr<=1; dr++) {
                        for(let dc=-1; dc<=1; dc++) {
                            if(dr===0 && dc===0) continue;
                            targets.push({r: toR+dr, c: toC+dc});
                        }
                    }
                    
                    let hit = false;
                    targets.forEach(p => {
                        if(p.r>=0 && p.r<currentRows && p.c>=0 && p.c<currentCols) {
                            const t = newBoard[p.r][p.c];
                            if(t && !t.isObstacle) {
                                const tInfo = getPieceInfo(t.type);
                                newHands[turn].push({ type: t.type, owner: turn, promoted: false, skillCharges: tInfo.skill?.maxCharges || 0 });
                                newBoard[p.r][p.c] = null;
                                hit = true;
                            }
                        }
                    });
                    if (hit) {
                        triggerEffect('explosion', targets);
                        playSound('capture');
                    }
                }

                // Handle Events
                if (troubleTriggered) setCutIn({ type: 'TROUBLE', text: 'TROUBLE', subText: 'BETRAYAL' });
                else if (didSplit) setCutIn({ type: 'SPLIT', text: 'SPLIT', subText: 'DOUBLE TROUBLE' });
                else if (captureOccurred && info.skill?.type !== 'CORRUPTION') { setCutIn({ type: 'CAPTURE', text: 'CAPTURE', subText: '' }); playSound('capture'); }
                else if (!boardExpanded) playSound('place');

                // Decide Next State
                if (canExplode) {
                    setExplosionPending({ board: newBoard, hands: newHands, r: toR, c: toC, prev: from.type==='board'?{r:from.r,c:from.c}:null });
                } else if (mustPromote) {
                    pieceObj.promoted = true;
                    if(info.skill?.reloadAmount) pieceObj.skillCharges = info.skill.reloadAmount;
                    setCutIn({ type: 'PROMOTION', text: 'PROMOTION', subText: '' });
                    updateGameState(newBoard, newHands, {r:toR, c:toC}, from.type==='board'?{r:from.r,c:from.c}:null);
                } else if (canPromote && from.type === 'board') {
                    setPromotionPending({ board: newBoard, hands: newHands, r: toR, c: toC, turn, prev: {r:from.r, c:from.c} });
                } else {
                    updateGameState(newBoard, newHands, {r:toR, c:toC}, from.type==='board'?{r:from.r,c:from.c}:null);
                }
            };

            const updateGameState = (newBoard, newHands, moveLoc, prevLoc) => {
                const nextTurn = turn === PLAYERS.SENTE ? PLAYERS.GOTE : PLAYERS.SENTE;
                
                // Clear Frozen state for the player whose turn is starting
                newBoard.forEach(row => row.forEach(cell => {
                    if (cell && cell.frozen && cell.owner === nextTurn) {
                        cell.frozen = false;
                    }
                }));

                setBoard(newBoard);
                setHands(newHands);
                setTurn(nextTurn);
                setSelected(null);
                setValidDestinations([]);
                setSkillMode(false);
                setBrainwashState(null);
                setPromotionPending(null);
                setExplosionPending(null);
                if (moveLoc) setLastMove({ from: prevLoc, to: moveLoc });
            };

            const resolvePromotion = (shouldPromote) => {
                const { board: b, hands: h, r, c, prev } = promotionPending;
                const nb = b.map(row => row.map(cell => cell ? {...cell} : null));
                if (shouldPromote) {
                    nb[r][c].promoted = true;
                    const info = getPieceInfo(nb[r][c].type);
                    if(info.skill?.reloadAmount) nb[r][c].skillCharges = info.skill.reloadAmount;
                    setCutIn({ type: 'PROMOTION', text: 'PROMOTION', subText: '' });
                    playSound('promote');
                }
                updateGameState(nb, h, {r,c}, prev);
            };

            const resolveExplosion = (shouldExplode) => {
                const { board: b, hands: h, r, c, prev } = explosionPending;
                if (!shouldExplode) { updateGameState(b, h, {r,c}, prev); return; }
                
                const nb = b.map(row => row.map(cell => cell ? {...cell} : null));
                const nh = { ...h, [PLAYERS.SENTE]: [...h[PLAYERS.SENTE]], [PLAYERS.GOTE]: [...h[PLAYERS.GOTE]] };
                const targets = [];
                const rows = nb.length;
                const cols = nb[0].length;
                for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) targets.push({r:r+dr, c:c+dc});
                triggerEffect('explosion', targets);

                const me = nb[r][c];
                nb[r][c] = null;
                const opp = turn === PLAYERS.SENTE ? PLAYERS.GOTE : PLAYERS.SENTE;
                nh[opp].push({ type: me.type, owner: opp, promoted: false, skillCharges: getPieceInfo(me.type).skill?.maxCharges || 0 });

                targets.forEach(t => {
                    if(t.r>=0 && t.r<rows && t.c>=0 && t.c<cols && nb[t.r][t.c] && !nb[t.r][t.c].isObstacle && getPieceInfo(nb[t.r][t.c].type).rarity !== RARITY.SSR) nb[t.r][t.c] = null;
                });
                setCutIn({ type: 'EXPLOSION', text: 'EXPLOSION', subText: 'SACRIFICE' });
                updateGameState(nb, nh, {r,c}, prev);
            };

            const resetGame = () => {
                if (window.confirm('Reset Game?')) {
                    setBoard(createInitialBoard());
                    setTurn(PLAYERS.SENTE);
                    setHands(DEFAULT_HANDS);
                    setSelected(null);
                    setLastMove(null);
                    setCutIn(null);
                    setSkillMode(false);
                }
            };
            
            const dismissCutIn = () => setCutIn(null);

            return {
                board, turn, hands, selected, validDestinations, lastMove, cutIn, skillMode,
                promotionPending, explosionPending, movingPiece, effects,
                actions: {
                    handleBoardClick, handleHandClick, resolvePromotion, resolveExplosion, resetGame, completeAnimation,
                    dismissCutIn
                },
                refs: { playSound }
            };
        };

        /* =========================================
           5. MAIN APP CONTAINER
           ========================================= */

        function ModernShogi() {
            const game = useShogiGame();
            const boardRef = useRef(null);
            const cellRefs = useRef([]); 
            
            // Dynamic Refs for dynamic board
            const setCellRef = useCallback((r, c, el) => {
                if (!cellRefs.current[r]) cellRefs.current[r] = [];
                cellRefs.current[r][c] = el;
            }, []);

            if (!game.board) return <div className="h-dvh w-full bg-white text-zinc-800 flex items-center justify-center">INITIALIZING...</div>;
            
            const rows = game.board.length;
            const cols = game.board[0].length;
            const isPortrait = rows > cols;

            return (
                <div className="h-dvh w-full flex flex-col items-center justify-between py-4 font-sans select-none overflow-hidden touch-none relative">
                    <ModernBackground isSkillMode={game.skillMode} />
                    
                    {/* UI Overlays */}
                    {game.skillMode && (
                        <div className="absolute top-1/4 left-0 right-0 text-center pointer-events-none z-20 animate-pulse">
                            <h2 className="text-4xl font-black text-red-500 tracking-widest bg-white/80 backdrop-blur inline-block px-4 py-1 rounded">SKILL MODE</h2>
                            <p className="text-sm font-bold text-red-600 mt-1 bg-white/80 inline-block px-2">TAP TARGET TO DETONATE</p>
                        </div>
                    )}
                    {game.cutIn && <CutInOverlay {...game.cutIn} onComplete={game.actions.dismissCutIn} />}
                    
                    <div className={`absolute inset-0 flex flex-col items-center justify-between ${game.cutIn?.type === 'EXPLOSION' || game.cutIn?.type === 'BOMB_SKILL' ? 'animate-[explosion-shake_0.5s]' : ''}`}>
                        
                        {/* Menu */}
                        <div className="absolute right-0 top-1/2 -translate-y-1/2 flex flex-col gap-2 p-2 z-40">
                            <div className="writing-vertical-rl text-[10px] text-zinc-400 tracking-widest uppercase mb-2">MODERN SHOGI</div>
                            <button onClick={game.actions.resetGame} className="p-3 bg-white/50 backdrop-blur rounded-full text-zinc-500 hover:text-zinc-800 border border-zinc-200 shadow-sm"><RotateCcw size={20} /></button>
                        </div>

                        {/* Top: Gote Hand */}
                        <div className="w-full flex justify-center rotate-180 transition-transform duration-500 z-10">
                            <div className="flex flex-col items-center gap-2 w-full max-w-[320px] sm:max-w-md">
                                <PlayerLabel owner={PLAYERS.GOTE} currentTurn={game.turn} />
                                <ModernHand owner={PLAYERS.GOTE} pieces={game.hands[PLAYERS.GOTE]} isTurn={game.turn === PLAYERS.GOTE} onPieceClick={game.actions.handleHandClick} selected={game.selected} />
                            </div>
                        </div>

                        {/* Center: Board */}
                        <div className="flex-1 w-full flex items-center justify-center px-2 py-2 overflow-hidden z-10" ref={boardRef}>
                             <div 
                                className={`
                                    relative p-1 sm:p-2 border rounded-sm shadow-xl transition-colors duration-300 
                                    ${game.skillMode ? 'bg-red-50 border-red-300' : 'bg-white border-zinc-200'}
                                    /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã‚µã‚¤ã‚ºèª¿æ•´: ç¸¦ç”»é¢ã¯å¹…åŸºæº–ã€æ¨ªç”»é¢ã¯é«˜ã•åŸºæº– */
                                    w-full h-auto landscape:w-auto landscape:h-full
                                    max-w-full max-h-full
                                `}
                                style={{ 
                                    aspectRatio: `${cols}/${rows}`,
                                }}
                             >
                               <div 
                                    className={`grid gap-px border transition-colors duration-300 ${game.skillMode ? 'bg-red-200 border-red-300' : 'bg-zinc-300 border-zinc-300'}`}
                                    style={{ 
                                        gridTemplateColumns: `repeat(${cols}, 1fr)`,
                                        gridTemplateRows: `repeat(${rows}, 1fr)`,
                                        width: '100%',
                                        height: '100%'
                                    }}
                               >
                                 {game.board.map((row, r) => row.map((cell, c) => (
                                     <BoardCell 
                                        key={`${r}-${c}`} r={r} c={c} cell={cell}
                                        game={game} 
                                        cellRef={el => setCellRef(r, c, el)}
                                        onClick={() => game.actions.handleBoardClick(r, c, cellRefs, boardRef)}
                                     />
                                 )))}
                               </div>
                             </div>

                             {game.promotionPending && <PromotionModal pending={game.promotionPending} onChoice={game.actions.resolvePromotion} />}
                             {game.explosionPending && <ExplosionModal onChoice={game.actions.resolveExplosion} />}
                             {game.movingPiece && <FlyingPiece {...game.movingPiece} onComplete={game.actions.completeAnimation} />}
                        </div>

                        {/* Bottom: Sente Hand */}
                        <div className="w-full flex justify-center z-10">
                            <div className="flex flex-col items-center gap-2 w-full max-w-[320px] sm:max-w-md">
                                <PlayerLabel owner={PLAYERS.SENTE} currentTurn={game.turn} />
                                <ModernHand owner={PLAYERS.SENTE} pieces={game.hands[PLAYERS.SENTE]} isTurn={game.turn === PLAYERS.SENTE} onPieceClick={game.actions.handleHandClick} selected={game.selected} />
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const PlayerLabel = ({ owner, currentTurn }) => (
            <div className={`flex items-center gap-2 px-4 py-1 border rounded-full text-xs tracking-wide transition-all duration-300 ${currentTurn === owner ? 'border-zinc-800 bg-zinc-800 text-white shadow-md' : 'border-zinc-300 text-zinc-400'}`}>
                <span className={`w-1.5 h-1.5 rounded-full ${currentTurn === owner ? 'bg-white' : 'bg-zinc-400'}`}></span>
                PLAYER {owner.toUpperCase()}
            </div>
        );

        const BoardCell = ({ r, c, cell, game, cellRef, onClick }) => {
            const isSelected = game.selected && game.selected.type === 'board' && game.selected.r === r && game.selected.c === c;
            const isValidDest = game.validDestinations.some(m => m.r === r && m.c === c);
            const isLastMoveSrc = game.lastMove?.from?.r === r && game.lastMove?.from?.c === c;
            const isLastMoveDst = game.lastMove?.to?.r === r && game.lastMove?.to?.c === c;
            const isMovingSource = game.movingPiece && game.movingPiece.fromPos !== 'hand' && game.movingPiece.fromPos.r === r && game.movingPiece.fromPos.c === c;
            const showPiece = cell && !isMovingSource;

            const isExploding = game.effects.explosion.some(ec => ec.r === r && ec.c === c);
            const isSplitting = game.effects.split.some(ec => ec.r === r && ec.c === c);
            const isWind = game.effects.wind.some(ec => ec.r === r && ec.c === c);

            // Hole logic
            if (cell && cell.isObstacle) {
                return (
                    <div 
                        ref={cellRef}
                        className="w-full h-full bg-zinc-800 relative shadow-inner flex items-center justify-center overflow-hidden"
                    >
                         <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_#000_30%,_transparent_70%)] opacity-80"></div>
                         <div className="text-zinc-700 font-bold text-[8px] sm:text-[10px] select-none">VOID</div>
                    </div>
                );
            }

            return (
                <div 
                    ref={cellRef}
                    onClick={onClick}
                    className={`
                        w-full h-full
                        flex items-center justify-center relative transition-colors duration-200
                        ${isExploding ? 'explosion-fade' : ''} ${isSplitting ? 'split-fade' : ''} ${isWind ? 'wind-fade' : ''}
                        ${game.skillMode ? 'bg-red-50/50 hover:bg-red-200 cursor-crosshair' : 'bg-white'}
                        ${isValidDest ? 'cursor-pointer' : ''}
                    `}
                >
                    {!game.skillMode && isLastMoveSrc && <div className="absolute inset-0 bg-yellow-100" />}
                    {!game.skillMode && isLastMoveDst && <div className="absolute inset-0 bg-yellow-100/50" />}
                    
                    {isValidDest && (
                        <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none">
                        <div className="w-2 h-2 bg-red-400/50 rounded-full"></div>
                        {cell && <div className="absolute inset-0 border border-red-400"></div>}
                        </div>
                    )}
                    
                    {game.skillMode && (
                        <div className="absolute inset-0 flex items-center justify-center opacity-0 hover:opacity-50 pointer-events-none z-20 text-red-600">
                            <Crosshair size={24} />
                        </div>
                    )}

                    {showPiece && (
                        <ModernPiece 
                            type={cell.type} owner={cell.owner} promoted={cell.promoted}
                            charges={cell.skillCharges} isSelected={isSelected}
                        />
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ModernShogi />);
    </script>
</body>
</html>
